//! A library to work with the PointCloud2 message type from ROS.
//!
//! ros_pointcloud2 mainly provides a [`ros_pointcloud2::PointCloud2Msg`] type that implements
//! functions for conversion to and from iterators.
//!
//! - [`ros_pointcloud2::PointCloud2Msg::try_from_iterable`]
//! - [`ros_pointcloud2::PointCloud2Msg::try_into_iter`]
//!
//! For ROS interoperability, the message type generated by the respective crate must be converted to
//! the [`ros_pointcloud2::PointCloud2Msg`] using the `From` trait,
//! which mostly does ownership transfers without copying the point data.
//!
//! There are implementations for the `r2r`, `rclrs` (ros2_rust) and `rosrust_msg` message types
//! available in the feature flags. If you miss a message type, please open an issue or a PR.
//! See the [`ros_pointcloud2::ros_types`] module for more information.
//!
//! Common point types like [`ros_pointcloud2::pcl_utils::PointXYZ`] or
//! [`ros_pointcloud2::pcl_utils::PointXYZI`] are provided in the
//! [`ros_pointcloud2::pcl_utils`] module. You can implement any custom point type
//! that can be described by the specification.
//!
//! # Example PointXYZ
//! ```
//! use ros_pointcloud2::{PointCloud2Msg, pcl_utils::PointXYZ};
//!
//! // PointXYZ is predefined
//! let cloud_points = vec![
//!   PointXYZ {x: 9.0006, y: 42.0, z: -6.2,},
//!   PointXYZ {x: f32::MAX, y: f32::MIN,z: f32::MAX,},
//! ];
//!
//! // For equality test later
//! let cloud_copy = cloud_points.clone();
//!
//! // Give the Vec or anything that implements `IntoIterator`.
//! let in_msg = PointCloud2Msg::try_from_iterable(cloud_points).unwrap();
//!
//! // Convert to your ROS crate message type, we will use r2r here.
//! // let msg: r2r::sensor_msgs::msg::PointCloud2 = in_msg.into();
//! // Publish ...
//! // ... now incoming from a topic.
//! // let in_msg: PointCloud2Msg = msg.into();
//!
//! let new_pcl = in_msg.try_into_iter().unwrap()
//!     .map(|point: PointXYZ| { // Define the data you want from the point
//!         // Some logic here
//!
//!         point
//!     })
//!     .collect::<Vec<_>>(); // iterating points here O(n)
//!
//! assert_eq!(new_pcl, cloud_copy);
//! ```

pub mod convert;
pub mod pcl_utils;
pub mod ros_types;

/// Macro to get the size of a type at compile time. This is a convenience macro to avoid writing out the full std::mem::size_of::<T>().
/// Use it for your custom point conversion implementations with the [`ros_pointcloud2::PointConvertible`] trait.
#[macro_export]
macro_rules! size_of {
    ($t:ty) => {
        std::mem::size_of::<$t>()
    };
}

pub mod iterator;
use crate::convert::{FieldDatatype, FromBytes};
use crate::ros_types::{HeaderMsg, PointFieldMsg};
pub use convert::MetaNames;

/// All errors that can occur while converting to or from the PointCloud2 message.
#[derive(Debug)]
pub enum ConversionError {
    /// The coordinate field does not match the expected datatype.
    InvalidFieldFormat,

    /// Not enough meta or dimensional fields in the PointCloud2 message.
    NotEnoughFields,

    /// The dimensionality of the point inside the message is too high.
    TooManyDimensions,

    /// The field type is not supported by the ROS message description.
    UnsupportedFieldType,

    /// There are no points in the point cloud.
    NoPoints,

    /// The length of the byte buffer in the message does not match the expected length computed from the fields.
    DataLengthMismatch,
}

#[inline(always)]
fn add_point_to_byte_buffer<T, const SIZE: usize, const DIM: usize, const METADIM: usize, C>(
    coords: C,
    cloud: &mut PointCloud2Msg,
) -> Result<bool, ConversionError>
where
    C: PointConvertible<T, SIZE, DIM, METADIM>,
    T: FromBytes,
{
    let point: Point<T, DIM, METADIM> = coords.into();

    // (x, y, z...)
    point
        .coords
        .iter()
        .for_each(|x| cloud.data.extend_from_slice(T::bytes(x).as_slice()));

    // meta data description
    point.meta.iter().for_each(|meta| {
        let truncated_bytes = &meta.bytes[0..meta.datatype.size()];
        cloud.data.extend_from_slice(truncated_bytes);
    });

    cloud.width += 1;

    Ok(true)
}

#[derive(Clone, Debug, Default)]
pub struct PointCloud2Msg {
    pub header: HeaderMsg,
    pub height: u32,
    pub width: u32,
    pub fields: Vec<PointFieldMsg>,
    pub is_bigendian: bool,
    pub point_step: u32,
    pub row_step: u32,
    pub data: Vec<u8>,
    pub is_dense: bool,
}

impl PointCloud2Msg {
    /// Create a PointCloud2Msg from any iterable type.
    ///
    /// The operation is O(n) in time complexity where n is the number of points in the point cloud.
    ///
    /// # Example
    /// ```
    /// use ros_pointcloud2::{
    ///     pcl_utils::PointXYZ, PointCloud2Msg,
    /// };
    ///
    /// let cloud_points: Vec<PointXYZ> = vec![
    ///     PointXYZ { x: 1.0, y: 2.0, z: 3.0 },
    ///     PointXYZ { x: 4.0, y: 5.0, z: 6.0 },
    /// ];
    ///
    // let msg_out = PointCloud2Msg::try_from_iterable(cloud_points).unwrap();
    /// ```
    pub fn try_from_iterable<T, const SIZE: usize, const DIM: usize, const METADIM: usize, C>(
        iterable: impl IntoIterator<Item = C>,
    ) -> Result<Self, ConversionError>
    where
        C: PointConvertible<T, SIZE, DIM, METADIM>,
        T: FromBytes,
    {
        if DIM > 3 {
            return Err(ConversionError::TooManyDimensions); // maybe can be checked at compile time?
        }

        let mut iter = iterable.into_iter();
        let mut fields = Vec::with_capacity(METADIM + DIM); // TODO check if we can preallocate the size on the stack

        if DIM > 1 {
            fields.push(PointFieldMsg {
                name: "x".into(),
                offset: 0,
                datatype: T::field_datatype().into(),
                count: 1,
            });

            fields.push(PointFieldMsg {
                name: "y".into(),
                offset: SIZE as u32,
                datatype: T::field_datatype().into(),
                count: 1,
            });
        }

        if DIM == 3 {
            fields.push(PointFieldMsg {
                name: "z".into(),
                offset: 2 * SIZE as u32,
                datatype: T::field_datatype().into(),
                count: 1,
            });
        }

        let first_point = iter.next().ok_or(ConversionError::NoPoints)?;
        let point: Point<T, DIM, METADIM> = first_point.clone().into();
        let meta_names = C::meta_names();

        let mut meta_offsets_acc = DIM as u32 * SIZE as u32;
        for (meta_value, meta_name) in point.meta.into_iter().zip(meta_names.into_iter()) {
            let datatype_code = meta_value.datatype.into();
            if FieldDatatype::try_from(datatype_code).is_err() {
                return Err(ConversionError::UnsupportedFieldType);
            }

            fields.push(PointFieldMsg {
                name: meta_name.into(),
                offset: meta_offsets_acc,
                datatype: datatype_code,
                count: 1,
            });
            meta_offsets_acc += meta_value.datatype.size() as u32
        }

        let mut cloud = PointCloud2Msg {
            point_step: fields.iter().fold(Default::default(), |acc, field| {
                let field_type: FieldDatatype = field
                    .datatype
                    .try_into()
                    .expect("Unsupported field but checked before.");
                let field_size = field_type.size();
                acc + field.count * field_size as u32
            }),
            ..Default::default()
        };

        // actual point -> byte conversion -- O(n)
        add_point_to_byte_buffer(first_point, &mut cloud)?;
        for coords in iter {
            add_point_to_byte_buffer(coords, &mut cloud)?;
        }

        cloud.fields = fields;
        cloud.height = 1; // everything is in one row (unstructured)
        cloud.is_bigendian = false; // ROS default
        cloud.is_dense = true; // ROS default
        cloud.row_step = cloud.width * cloud.point_step; // Note: redundant but defined in PointCloud2 message

        Ok(cloud)
    }

    pub fn try_into_iter<T, const SIZE: usize, const DIM: usize, const METADIM: usize, C>(
        self,
    ) -> Result<impl Iterator<Item = C>, ConversionError>
    where
        C: PointConvertible<T, SIZE, DIM, METADIM>,
        T: FromBytes,
    {
        iterator::PointCloudIterator::try_from(self)
    }
}

/// Internal point representation. It is used to store the coordinates and meta data of a point.
/// In each iteration, an internal point representation is converted to the desired point type.
/// Implement the `From` traits for your point type to use the conversion.
///
/// See the [`ros_pointcloud2::PointConvertible`] trait for more information.
pub struct Point<T, const DIM: usize, const METADIM: usize> {
    pub coords: [T; DIM],
    pub meta: [PointMeta; METADIM],
}

/// Trait to enable point conversions on the fly while iterating.
///
/// Implement this trait for your custom point you want to read or write in the message.
///
/// # Example
/// ```
/// use ros_pointcloud2::{Point, PointConvertible, MetaNames, size_of};
///
/// #[derive(Clone, Debug, PartialEq, Copy)]
/// pub struct MyPointXYZI {
///     pub x: f32,
///     pub y: f32,
///     pub z: f32,
///     pub intensity: f32,
/// }
///
/// impl From<MyPointXYZI> for Point<f32, 3, 1> {
///     fn from(point: MyPointXYZI) -> Self {
///         Point {
///             coords: [point.x, point.y, point.z],
///             meta: [point.intensity.into()],
///         }
///     }
/// }
///
/// impl From<Point<f32, 3, 1>> for MyPointXYZI {
///     fn from(point: Point<f32, 3, 1>) -> Self {
///         Self {
///             x: point.coords[0],
///             y: point.coords[1],
///             z: point.coords[2],
///             intensity: point.meta[0].get(),
///         }
///     }
/// }
///
/// impl MetaNames<1> for MyPointXYZI {
///    fn meta_names() -> [&'static str; 1] {
///       ["intensity"]
///   }
/// }
///
/// impl PointConvertible<f32, {size_of!(f32)}, 3, 1> for MyPointXYZI {}
/// ```
pub trait PointConvertible<T, const SIZE: usize, const DIM: usize, const METADIM: usize>:
    From<Point<T, DIM, METADIM>> + Into<Point<T, DIM, METADIM>> + MetaNames<METADIM> + Clone + 'static
where
    T: FromBytes,
{
}

/// Metadata representation for a point.
///
/// This struct is used to store meta data in a fixed size byte buffer along the with the
/// datatype that is encoded so that it can be decoded later.
///
/// # Example
/// ```
/// use ros_pointcloud2::PointMeta;
///
/// let original_data: f64 = 1.0;
/// let meta = PointMeta::new(original_data);
/// let my_data: f64 = meta.get();
/// ```
#[derive(Debug, Clone, Copy)]
pub struct PointMeta {
    bytes: [u8; std::mem::size_of::<f64>()],
    datatype: FieldDatatype,
}

impl Default for PointMeta {
    fn default() -> Self {
        Self {
            bytes: [u8::default(); std::mem::size_of::<f64>()],
            datatype: FieldDatatype::F32,
        }
    }
}

impl PointMeta {
    /// Create a new PointMeta from a value.
    ///
    /// # Example
    /// ```
    /// let meta = ros_pointcloud2::PointMeta::new(1.0);
    /// ```
    #[inline(always)]
    pub fn new<T: FromBytes>(value: T) -> Self {
        let raw_bytes = T::bytes(&value);
        let mut bytes = [0; std::mem::size_of::<f64>()];
        for (byte, save_byte) in raw_bytes.into_iter().zip(bytes.iter_mut()) {
            *save_byte = byte;
        }

        Self {
            bytes,
            datatype: T::field_datatype(),
        }
    }

    #[inline(always)]
    fn from_buffer(data: &[u8], offset: usize, datatype: &FieldDatatype) -> Self {
        debug_assert!(data.len() >= offset + datatype.size());

        let bytes = unsafe { data.get_unchecked(offset..offset + datatype.size()) };
        let mut bytes_array = [0; std::mem::size_of::<f64>()]; // 8 bytes as f64 is the largest type
        for (byte, save_byte) in bytes.iter().zip(bytes_array.iter_mut()) {
            *save_byte = *byte;
        }

        Self {
            bytes: bytes_array,
            datatype: *datatype,
        }
    }

    /// Get the numeric value from the PointMeta description.
    ///
    /// # Example
    /// ```
    /// let original_data: f64 = 1.0;
    /// let meta = ros_pointcloud2::PointMeta::new(original_data);
    /// let my_data: f64 = meta.get();
    /// ```
    pub fn get<T: FromBytes>(&self) -> T {
        let size = T::field_datatype().size();
        let bytes = self
            .bytes
            .get(0..size)
            .expect("Exceeds bounds of f64, which is the largest type");
        T::from_le_bytes(bytes)
    }
}

impl From<f32> for PointMeta {
    fn from(value: f32) -> Self {
        Self::new(value)
    }
}

impl From<f64> for PointMeta {
    fn from(value: f64) -> Self {
        Self::new(value)
    }
}

impl From<i32> for PointMeta {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl From<u8> for PointMeta {
    fn from(value: u8) -> Self {
        Self::new(value)
    }
}

impl From<u16> for PointMeta {
    fn from(value: u16) -> Self {
        Self::new(value)
    }
}

impl From<u32> for PointMeta {
    fn from(value: u32) -> Self {
        Self::new(value)
    }
}

impl From<i8> for PointMeta {
    fn from(value: i8) -> Self {
        Self::new(value)
    }
}

impl From<i16> for PointMeta {
    fn from(value: i16) -> Self {
        Self::new(value)
    }
}
